import datetime
import logging
import uuid
from enum import Enum

from django.contrib.auth.models import AbstractUser
from django.core.validators import MaxValueValidator, MinValueValidator
from django.db import models
from django.urls import reverse
from django.utils.translation import gettext_lazy as _

from kinesinlms.core.models import Trackable

logger = logging.getLogger(__name__)


class GroupTypes(Enum):
    # An "educator" is a user who has access to
    # the special levels of information, including
    # educator resources for courses.
    # However, they must also be made a "CourseStaff" for a
    # course in order to access a particular course's educator resources.
    EDUCATOR = "educator"

    # An "author" is a use who is allowed to author courses.
    AUTHOR = "author"


class CareerStageType(object):
    # The somewhat confusing string values used here
    # are a consequence of our earlier use of Open edX.
    UNDERGRADUATE = "b"
    MASTERS = "m"
    DOCTORATE = "p"
    POST_DOCTORAL = "r"
    EARLY_CAREER_PRE_TENURE_FACULTY = "e"
    NON_TENURE_TRACK_FACULTY = "n"
    TENURED_FACULTY = "t"
    RESEARCHER_STAFF_SCIENTIST = "rss"
    ADMINISTRATOR = "a"
    PROFESSIONAL_DEVELOPMENT = "s"
    OTHER = "o"


class GenderType(Enum):
    FEMALE = "Female"
    MALE = "Male"
    NON_BINARY = "Non-binary"
    NOT_LISTED = "Not listed"
    PREFER_NOT_TO_ANSWER = "Prefer not to answer"


def current_year():
    return datetime.date.today().year


def max_value_current_year(value):
    return MaxValueValidator(current_year())(value)


BOOLEAN_YN = (
    (True, "Yes"),
    (False, "No"),
)


class Prospect(models.Model):
    """
    A Prospect is some person who has had more than fleeting interaction with our site,
    but isn't yet a proper user.
    At first, this mostly means people who have filled out "give me more info" forms
    or things like that.
    """

    email = models.EmailField(_("Email"), null=False, blank=False)

    name = models.CharField(_("Name"), max_length=200, null=True, blank=True)

    institution = models.CharField(
        _("Institution"), max_length=200, null=True, blank=True
    )

    # Internal field not shown to user in form.
    source = models.CharField(
        max_length=50,
        help_text=_("Internal source for this prospect, e.g. download resource view."),
    )

    consent = models.BooleanField(
        _("Consent"),
        default=False,
        choices=BOOLEAN_YN,
        null=True,
        help_text=_("Consent tosubmitted data being " "collected and stored."),
        blank=False,
    )


class InviteUser(Trackable):
    """
    Describes a user who has been invited to register.
    Upon registering, this user should be enrolled
    in a specific course.
    """

    email = models.EmailField(_("Email"), null=False, blank=False)

    cohort = models.ForeignKey(
        "course.Cohort",
        null=False,
        blank=False,
        on_delete=models.CASCADE,
        related_name="invited_users",
    )

    manual_enrollment = models.ForeignKey(
        "management.ManualEnrollment",
        null=True,
        blank=True,
        on_delete=models.CASCADE,
        related_name="invited_users",
    )

    email_sent_date = models.DateTimeField(null=True, blank=True)

    registered_date = models.DateTimeField(null=True, blank=True)


class User(AbstractUser):
    # First Name and Last Name do not cover name patterns
    # around the globe. So this is our "Full Name" field.
    name = models.CharField(_("Name of user"), null=True, blank=True, max_length=500)

    # However we need an informal name for emails.
    informal_name = models.CharField(
        _("What shall we call you (for example, when we send you mail)?"),
        null=True,
        max_length=255,
        blank=True,
    )

    is_staff = models.BooleanField(default=False, null=False)

    is_test_user = models.BooleanField(
        default=False,
        null=False,
        help_text=_(
            "Flag this user as a tester. Don't count interactions in analytics."
        ),
    )

    # Autogenerated "anonymous" username for a user. This field should be used for analytics tracking logs.
    anon_username = models.UUIDField(
        primary_key=False, default=uuid.uuid4, editable=True
    )

    career_stage_choices = (
        (CareerStageType.UNDERGRADUATE, "Undergraduate"),
        (CareerStageType.MASTERS, "Master's or professional degree"),
        (CareerStageType.DOCTORATE, "Doctorate"),
        (CareerStageType.POST_DOCTORAL, "Postdoctoral researcher"),
        (
            CareerStageType.EARLY_CAREER_PRE_TENURE_FACULTY,
            "Early career faculty member (pre-tenure)",
        ),
        (CareerStageType.NON_TENURE_TRACK_FACULTY, "Non - tenure track faculty member"),
        (CareerStageType.TENURED_FACULTY, "Tenured faculty"),
        (CareerStageType.RESEARCHER_STAFF_SCIENTIST, "Researcher / staff scientist"),
        (CareerStageType.ADMINISTRATOR, "Administrator"),
        (
            CareerStageType.PROFESSIONAL_DEVELOPMENT,
            "Professional development / career development staff",
        ),
        (CareerStageType.OTHER, "Other"),
    )

    career_stage = models.CharField(
        max_length=10,
        help_text=_("Career stage"),
        choices=career_stage_choices,
        blank=True,
        null=True,
    )

    gender = models.CharField(
        max_length=100,
        help_text=_("Gender"),
        choices=[(item.name, item.value) for item in GenderType],
        blank=True,
        null=True,
    )

    gender_description = models.CharField(
        _("Gender description"), max_length=100, blank=True, null=True
    )

    year_of_birth = models.IntegerField(
        _("Year of birth"),
        null=True,
        blank=True,
        validators=[MinValueValidator(1900), max_value_current_year],
    )

    why_interested = models.TextField(
        _("Why interested in this website"), null=True, blank=True
    )

    agree_to_honor_code = models.BooleanField(
        _("Agree to Honor Code"), null=False, blank=False, default=False
    )

    # The id for the user in our email automation service, (if one exists).

    email_automation_provider_user_id = models.CharField(
        max_length=100,
        null=True,
        blank=True,
        help_text=_(
            "The ID for the user in the email automation provider, " "(if one exists)."
        ),
    )

    def get_settings(self):
        if hasattr(self, "settings"):
            return self.settings
        else:
            settings = UserSettings.objects.create(user=self)
            return settings

    def get_absolute_url(self) -> str:
        return reverse("users:detail", kwargs={"username": self.username})

    @property
    def is_educator(self) -> bool:
        return self.groups.filter(name=GroupTypes.EDUCATOR.name).exists()

    @property
    def is_reviewer(self):
        return (
            self.is_superuser
            or self.is_staff
            or self.groups.filter(name="Reviewers").exists()
        )

    @property
    def career_stage_name(self):
        try:
            for choice in self.career_stage_choices:
                if choice[0] == self.career_stage:
                    return choice[1]
        except Exception:
            logger.exception(f"Could not get career_stage_name for {self}")
            return None

    @property
    def gender_name(self):
        try:
            if self.gender:
                return GenderType[self.gender].value
        except Exception:
            logger.exception(f"Could not get gender_name for {self}")
            return None

    def age(self):
        if self.year_of_birth and self.year_of_birth > 0:
            today = datetime.date.today()
            return today.year - self.year_of_birth
        return None


class UserSettings(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name="settings")

    enable_badges = models.BooleanField(
        _("Enable badges"),
        default=True,
        help_text=_(
            "Enable badges for 'course passed' and " "other milestone achievements."
        ),
    )

    def __str__(self):
        return f"UserSettings for {self.user}"
